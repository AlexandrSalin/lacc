#include "error.h"
#include "type.h"
#include "symbol.h"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Let every namespace have a list of scopes, to optimize lookup for a
 * particular scope depth. Store indices into namespace list of symbols.
 */
typedef struct scope {
    int *idx;
    int size;
    int cap;
} scope_t;


void push_scope(namespace_t *ns) {
    assert(ns);

    ns->depth++;
    if (!ns->scope) {
        ns->depth = 0;
    }
    ns->scope = realloc(ns->scope, sizeof(scope_t) * (ns->depth + 1));
    memset(&ns->scope[ns->depth], 0x0, sizeof(scope_t));

    if (ns->depth == 1) {
        ns->var_stack_offset = 8;
        ns->param_number = 1;
    } else if (ns->depth == 2) {
        ns->var_stack_offset = 0;
    }
}

void pop_scope(namespace_t *ns) {
    if (ns->depth >= 0) {
        if (ns->scope[ns->depth].idx) {
            free(ns->scope[ns->depth].idx);    
        }
        memset(&ns->scope[ns->depth], 0x0, sizeof(scope_t));
        ns->depth--;
    }
    if (ns->depth == -1) {
        if (ns->scope) {
            free(ns->scope);
        }
        ns->scope = NULL;
    }
}


/* Create and add symbol to symbol table, but not to any scope. Symbol address
 * needs to be stable, so they are stored as a realloc'able list of pointers.
 */
static int
create_symbol(namespace_t *ns, symbol_t sym)
{
    sym.depth = ns->depth;
    if (ns->size == ns->capacity) {
        ns->capacity += 64;
        ns->symbol = realloc(ns->symbol, sizeof(symbol_t*) * ns->capacity);
    }

    ns->symbol[ns->size] = calloc(1, sizeof(symbol_t));
    *(ns->symbol[ns->size]) = sym;

    return ns->size++;
}

/* Create a temporary identifier name. Use a fixed prefix '.' to
 * all temporary variables, which will never collide with real symbols.
 */
static char *
prefixed_temporary_name(char prefix)
{
    static int tmpn;
    static char tmpname[16];

    snprintf(tmpname, 12, ".%c%d", prefix, tmpn++);

    return tmpname;
}

/* Add symbol to current scope, making it possible to look up. Name must be non-
 * NULL, i.e. immediate values do not belong to any scope.
 */
static void
register_in_scope(namespace_t *ns, int i)
{
    scope_t *scope;

    assert(i < ns->size);
    scope = &ns->scope[ns->depth];
    if (scope->size == scope->cap) {
        scope->cap += 16;
        scope->idx = realloc(scope->idx, scope->cap * sizeof(int *));
    }
    scope->idx[scope->size] = i;
    scope->size++;
}

/* Retrieve a symbol based on identifier name, or NULL of not registered or
 * visible from current scope.
 */
symbol_t *
sym_lookup(namespace_t *ns, const char *name)
{
    int i, d;

    assert(ns);
    for (d = ns->depth; d >= 0; --d) {
        for (i = 0; i < ns->scope[d].size; ++i) {
            int idx = ns->scope[d].idx[i];
            if (!strcmp(name, ns->symbol[idx]->name)) {
                return ns->symbol[idx];
            }
        }
    }

    return NULL;
}

/* Add symbol to current scope. If the symbol already exists in the same scope
 * and has incomplete type, the type is completed.
 *
 * Calculate stack offset and function parameter index based on static context
 * variables. This is x86_64 specific, wrong if params cannot fit in registers.
 */
symbol_t *
sym_add(namespace_t *ns, const char *name, const typetree_t *type, enum storage_class stc)
{
    symbol_t *symbol;

    symbol = sym_lookup(ns, name);

    if (symbol && symbol->depth == ns->depth) {
        if (symbol->type->size) {
            error("Duplicate definition of symbol '%s'", name);
            exit(0);
        }
        symbol->type = type_complete(symbol->type, type);
    } else {
        int idx;
        symbol_t sym = {0};
        sym.name = strdup(name);
        sym.type = type;
        sym.storage = stc;

        if (ns->depth == 1) {
            sym.param_n = ns->param_number++;
            ns->var_stack_offset += type->size;
            if (sym.param_n > 6) {
                sym.stack_offset = ns->var_stack_offset;
            }
        } else if (ns->depth > 1) {
            ns->var_stack_offset -= type->size;
            sym.stack_offset = ns->var_stack_offset;
        }

        idx = create_symbol(ns, sym);
        register_in_scope(ns, idx);

        symbol = ns->symbol[idx];
    }

    return symbol;
}

/* Add temporary (autogenerated name) symbol to current scope.
 */
const symbol_t *
sym_temp(namespace_t *ns, const typetree_t *type)
{
    int idx;

    symbol_t sym = {0};
    sym.name = strdup( prefixed_temporary_name('t') );
    sym.type = type;
    sym.storage = STC_AUTO;

    if (ns->depth == 1) {
        ns->var_stack_offset += type->size;
        sym.stack_offset = ns->var_stack_offset;
    } else if (ns->depth > 1) {
        ns->var_stack_offset -= type->size;
        sym.stack_offset = ns->var_stack_offset;
    }

    idx = create_symbol(ns, sym);
    register_in_scope(ns, idx);

    return ns->symbol[idx];
}

/* Add temporary symbol refering to some static value.
 */
const symbol_t *
sym_temp_static(namespace_t *ns, const typetree_t *type)
{
    int idx;

    symbol_t sym = {0};
    sym.name = strdup( prefixed_temporary_name('d') );
    sym.type = type;

    idx = create_symbol(ns, sym);
    register_in_scope(ns, idx);

    return ns->symbol[idx];
}

/* Register compiler internal builtin symbols, that are assumed to exists by
 * standard library headers. Use dummy types for now. */
void
register_builtin_types(namespace_t *ns)
{
    sym_add(ns, "__builtin_va_list", type_init(OBJECT), STC_TYPEDEF);
}

void
dump_symtab(namespace_t *ns)
{
    int i;
    char *tstr;

    if (ns->size) {
        printf("namespace %s:\n", ns->name);
    }
    for (i = 0; i < ns->size; ++i) {
        printf("%*s", ns->symbol[i]->depth * 2, "");
        if (ns->symbol[i]->storage != STC_NONE) {
            enum storage_class stc = ns->symbol[i]->storage;
            printf("%s ", 
                (stc == STC_AUTO) ? "auto" : 
                (stc == STC_STATIC) ? "static" :
                (stc == STC_TYPEDEF) ? "typedef" : "extern");
        }
        printf("%s :: ", ns->symbol[i]->name);
        tstr = typetostr(ns->symbol[i]->type);
        printf("%s", tstr);
        free(tstr);
        printf(", size=%d", ns->symbol[i]->type->size);
        if (ns->symbol[i]->param_n) {
            if (ns->symbol[i]->stack_offset > 0) {
                printf(" (param: %d, offset: %d)", ns->symbol[i]->param_n, ns->symbol[i]->stack_offset);
            } else {
                printf(" (param: %d)", ns->symbol[i]->param_n);
            }
        }
        if (ns->symbol[i]->stack_offset < 0) {
            printf(" (auto: %d)", ns->symbol[i]->stack_offset);
        }
        if (ns->symbol[i]->storage == STC_NONE) {
            printf(", value=%d", ns->symbol[i]->enum_value);
        }
        printf("\n");
    }
}
